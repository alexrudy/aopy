
.. currentmodule:: aopy.atmosphere

.. |Screen| replace:: :class:`~aopy.atmosphere.screen.Screen`
.. |ManyLayerScreen| replace:: :class:`~aopy.atmosphere.wind.ManyLayerScreen`,

Modeling a Komolgorov Atmosphere
********************************

This module builds model atmospheric phase screens. The phase screens simulate
the phase delay found in a single wavefront of light which propogates through
Komolgorov turbulence. The generation of phase screens is split into two separate
classes: |Screen|, which builds and outputs static phase
screens, and |ManyLayerScreen| which creates many translating
layers of screens which can "blow" past a given aperture.

Static Komolgorov phase screens
===============================

Static Komolgorov phase screnes are generated once, and then can be used to simulate
a single piece of phase across an aperture. The phase screens rely on a random seed,
and can be regenerated. To build a phase screen, create a |Screen| object with
the apropriate shape and :math:`r_0` parameter::
    
    import astropy.units as u
    my_atmosphere = Screen((50, 50), 10 * u.cm)
    

By default, screens have 1 meter subaperutres, which can be changed with the `du` parameter.

Once you have created a screen object, you can generate a new phase screen by *calling* the
object, which will return a :class:`numpy.ndarray` populated with phase values.
The *physical* attributes of a |Screen| cannot be changed once it has been created,
but new, independent screens can be generated by calling the screen object::
    
    screen_one = my_atmosphere()
    screen_two = my_atmosphere()
    screen_one != screen_two
    

Seeded Screens
--------------

It is possible to seed a phase screen with a random number using the `seed` parameter
to the |Screen| constructor. The seed can also be changed by setting a new value
on the :attr:`Screen.seed <aopy.amosphere.screen.Screen.seed>` attribute. This will regenerate the phase screens with the 
new random number generator seed. When using a seed, calling the object to regenerate
a new phase screen::
    
    seeded_atmosphere = Screen((50,50), 10 * u.cm, seed=2)
    screen_one = seeded_atmosphere()
    seeded_atmosphere.seed = 5
    screen_two = my_atmosphere()
    screen_three = my_atmosphere()
    screen_three == screen_two
    screen_two != screen_one
    

Moving, Many Layer Phase Screens
================================

Many layer phase screens are constructed from multiple phase screens, which are added to
produce a single phase screen. Each screen can be translated independently, to simulate
the effect of one or many *frozen-flow* layers translating across a telescope aperture.
This |ManyLayerScreen| object accepts similar parameters to the |Screen| object, except
that it also accepts an array of wind velocities in the `vel` parameter, and array of
relative strengths (which will be re-normalized) in the `strength` parameter. To create
a single moving screen, at 1 m/s::
    
    WindScreen = ManyLayerScreen((50,50), 10 * u.cm, vel=[[0.0, 1.0 * u.m/u.s]])
    screen = WindScreen()
    
Each call ot the |ManyLayerScreen| object will not regenerate the screens, but instead
will translate them across the visible aperture. The |ManyLayerScreen| object can also
be used as an iterator::
    
    for screen in WindScreen:
        print("Do something with my screen!")
    

The length of the iterator is not well defined, as it supports wrapping around the
edge of the phase screen. The length returned by ``len(WindScreen)`` is the number
of iterations possible before the phase screen wraps around the end. The current
postion of the phase screen is stored in the 
:attr:`~aopy.atmosphere.wind.ManyLayerScreen.counter` attribute.

.. warning:: 
    The behavior of the screen as it wraps around the edge of the simulated phase
    is not well defined, and the RMS wavefront error may have a jagged edge as it
    wraps.

API/Reference
=============

.. automodapi:: aopy.atmosphere

Internal Phase Screen Functions
-------------------------------

The functions which are the underlying algorithm for :class:`Screen` are
contianed in :mod:`aopy.atmosphere.screen`. It is not recommended that you use them, 
but they are useful for testing this module against the original ``screengen.pro``, 
as is done in ``examples/screengen.py``.

.. autofunction:: aopy.atmosphere.screen._generate_filter

.. autofunction:: aopy.atmosphere.screen._generate_screen_with_noise

.. autofunction:: aopy.atmosphere.screen._generate_screen

Testing against IDL
-------------------

Using :mod:`pIDLy` to run and communicate with an IDL interpreter,
:mod:`nosetests` verifies that functions in :mod:`aopy.atmosphere.screen`
produce outputs consistent with `screengen.pro`. You can also verify
this result in more detail (noisier output...) using the script `test/screen.py`
which does similar comparisons.

.. warning::
    The testing uses IDL's ``randn`` function to generate consistent random values
    for comparison between python and IDL. In order for this to work properly,
    ``screengen.pro`` was modified: A new function ``screengen_fn`` was defined,
    identical to ``screengen_f``, except that ``screengen_fn`` accepts a noise vector
    for the subharmonic values, where ``screengen_f`` generates them on-the-fly.

    