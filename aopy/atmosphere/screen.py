# -*- coding: utf-8 -*-
# 
#  screengen.py
#  aopy
#  
#  Created by Jaberwocky on 2013-04-12.
#  Copyright 2013 Jaberwocky. All rights reserved.
#
"""
:mod:`atmosphere.screen <aopy.atmosphere.screen>` – Static Kolmolgorov Screen Generation
========================================================================================

This module is an object-oriented port of Don Gavel's ``screengen.pro``,
a program from generating Kolmolgorov phase screens.

:class:`Screen` – Static Kolmolgorov phase screens
--------------------------------------------------

.. autoclass::
    Screen
    :members:
    :exclude-members: get_screen
    

Internal Phase Screen Functions
-------------------------------

These functions are the underlying algorithm for :class:`Screen`. 
It is not recommended that you use them, but they are useful for testing
this module against the original ``screengen.pro``, as is done in ``examples/screengen.py``

.. autofunction::
    _generate_filter

.. autofunction::
    _generate_screen
    
.. autofunction::
    _generate_screen_with_noise

"""

from __future__ import (absolute_import, unicode_literals, division,
                        print_function)

import numpy as np

def _generate_filter(shape,r0,du,L0=None,nsh=0):
    """Generate the filter for this screen.
    
    :param shape: Shape of the desired screen.
    :param r0: :math:`r_0` fried parameter for the screen.
    :param L0: :math:`L_0` outer scale for the screen.
    :param nsh: Number of subharmonics to use. Results are good below ``nsh=8``
    :returns: ``(f,shf)``, a tuple where ``f`` is the filter, ``shf`` is the subharmonic filter.
    
    """
    n,m = shape
    dkx = 2 * np.pi / (n*du)
    dky = 2 * np.pi / (m*du)
    kx,ky = np.meshgrid((np.arange(n) - n//2) * dkx,(np.arange(m) - m//2) * dky,indexing='ij')
    if L0 is None:
        k0 = 0
    else:
        k0 = 2 * np.pi / L0
    k2 = np.power(kx,2) + np.power(ky,2) + (k0 ** 2.0)
    k2[n//2,m//2] = 1.0
    
    f = np.sqrt(0.023) * np.power(2.0 * np.pi / r0,5/6) * np.power(k2,-11/12) * np.sqrt(dkx * dky)
    
    f[n//2,m//2] = 0.0
    
    if nsh > 0:
        shf = np.zeros((8,nsh))
        for i in range(nsh):
            dkx = dkx/3.
            dky = dky/3.
            k2 = dkx**2 + dky**2 + k0**2
            shf[0,i] = k2**(-11./12.)*np.sqrt(dkx*dky)
            shf[1,i] = (dky**2+k0**2)**(-11./12.)*np.sqrt(dkx*dky)
            shf[2,i] = k2**(-11./12.)*np.sqrt(dkx*dky)
            shf[3,i] = (dkx**2+k0**2)**(-11./12.)*np.sqrt(dkx*dky)
            shf[4,i] = (dkx**2+k0**2)**(-11./12.)*np.sqrt(dkx*dky)
            shf[5,i] = k2**(-11./12.)*np.sqrt(dkx*dky)
            shf[6,i] = (dky**2+k0**2)**(-11./12.)*np.sqrt(dkx*dky)
            shf[7,i] = k2**(-11./12.)*np.sqrt(dkx*dky)
        shf = shf*np.sqrt(0.023)*(2*np.pi)**(5./6.)*r0**(-5./6.)
    else:
        shf = None
    
    return f, shf

def _generate_screen_with_noise(f,noise=None,shf=None,shnoise=None,du=1.0):
    """
    Generate a screen from a given grid of noise.
    
    :param f: Filter, from :func:`_generate_filter`
    :param noise: Noise, shame shape as ``f``, using a 'standard normal' distribution.
    :param shf: Subharmonic filter, from :func:`_generate_filter`
    :param shnoise: Subharmonic noise with a specific format.
    :returns: A screen with a shape matching ``f``
    
    Noise is properly generated by :func:`_generate_screen`, but if you want to 
    generate your own noise, you can use :mod:`numpy.random` as follows.
    
    **Noise Generation**
    To produce correct filter noise from a given ``seed``, use::
        
        import numpy.random
        rn = numpy.random.RandomState(seed).randn(*f.shape)
        
    
    **Subharmonic Noise**
    To produce subharmonic noise from a given ``seed``, use::
        
        import numpy.random
        _shn = numpy.random.RandomState(seed).randn(8)
        shnoise = (_shn[:4] + 1j*_shn[4:])/np.sqrt(2.0)
    
    """
    import scipy.fftpack
    rn = noise if noise is not None else np.ones(f.shape)
    frn = scipy.fftpack.fftshift(numpy.fft.fft2(rn)) * np.sqrt(np.prod(f.shape))
    s = scipy.fftpack.ifft2(numpy.fft.ifftshift(frn*f))
    if shf is not None:
        shn = shnoise if shnoise is not None else np.zeros((8,),dtype=np.complex)
        n,m = f.shape
        dkx = 2.0*np.pi/(n*du)
        dky = 2.0*np.pi/(m*du)
        y, x = (np.mgrid[0:n,0:m]).astype(np.float) * du
        rn = np.ones((8,),dtype=np.complex)
        nsh = shf.shape[1]
        for i in range(nsh):            
            rn[0:4] = shn
            rn[7] = np.conj(rn[0])
            rn[6] = np.conj(rn[1])
            rn[5] = np.conj(rn[2])
            rn[4] = np.conj(rn[3])
            dkx = dkx/3.0
            dky = dky/3.0
            s = s + rn[0]*shf[0,i]*np.exp(1j*(-dkx*x-dky*y))
            s = s + rn[1]*shf[1,i]*np.exp(1j*(-dky*y))
            s = s + rn[2]*shf[2,i]*np.exp(1j*(dkx*x-dky*y))
            s = s + rn[3]*shf[3,i]*np.exp(1j*(-dkx*y))
            s = s + rn[4]*shf[4,i]*np.exp(1j*(dkx*y))
            s = s + rn[5]*shf[5,i]*np.exp(1j*(-dkx*x+dky*y))
            s = s + rn[6]*shf[6,i]*np.exp(1j*(dky*y))
            s = s + rn[7]*shf[7,i]*np.exp(1j*(dkx*x+dky*y))
    return np.real(s)
    

def _generate_screen(f,seed=None,shf=None,du=None):
    """
    Generate a screen with noise.
    
    :param f: Filter, from :func:`_generate_filter`
    :param seed: Random number seed, to make noise suitable.
    :param shf: Subharmonic filter, from :func:`_generate_filter`
    :param du: Pixels per subaperture
    :returns: A screen with a shape matching ``f``
    
    """
    import numpy.random
    rn = numpy.random.RandomState(seed).randn(*f.shape)
    _shn = numpy.random.RandomState(seed).randn(8)
    shn = (_shn[:4] + 1j*_shn[4:])/np.sqrt(2.0)
    return _generate_screen_with_noise(f,rn,shf,shn,du)

class Screen(object):
    """A static Kolmolgorov Phase Screen Class. This class builds a Komologorv Filter and then generates a phase screen for that filter.
    Once a single phase screen has been generated, it is cached in the object. For a new phase screen, set a different :attr:`seed` value.
    
    :param tuple shape: The shape of the screen (x,y), as a tuple.
    :param float r0: :math:`r_0` fried parameter for the screen.
    :param float L0: :math:`L_0` outer scale for the screen.
    :param int seed: Random number generator seed for :mod:`numpy.random`
    :param float du: Pixels per subaperture
    :param int nsh: Number of subharmonics. (default``=0`` for no subharmonics)
    
    To use this class, you must instantiate it, and then call :meth:`setup`. Since :meth:`setup` returns the instance, you can do::
        
        screen = Screen((10,10),r0=2).setup()
    
    .. note:: This initialization process is done to delay generating the screen, especially in large or multi-layer screen cases.
    """
    def __init__(self, shape, r0, seed=None, du=1.0, L0=None, nsh=0):
        super(Screen, self).__init__()
        
        if not isinstance(shape,tuple) and len(shape) == 2:
            raise ValueError("shape must be a tuple of (x,y)!")
        
        # Parameters
        self._shape = shape
        self._r0 = r0
        self._du = du
        self._L0 = L0
        self._nsh = nsh
        self._seed = seed
        
        # Generated Quantities
        self._shf = None
        self._filter = None
        self._screen = None
        
    @property
    def shape(self):
        """Shape of the screen (n x m). **Read Only**"""
        return self._shape
        
    @property
    def r0(self):
        """Fried's parameter :math:`r_0`, the coherence length for the screen. **Read Only**"""
        return self._r0
        
    @property
    def L0(self):
        """The outer scale length of the turbulence, :math:`L_0`. **Read Only**"""
        return self._L0
        
    @property
    def du(self):
        """Pixels per subaperture. **Read Only**"""
        return self._du
        
    @property
    def nsh(self):
        """Number of sub-harmonics. **Read Only**"""
        return self._nsh
        
    @property
    def seed(self):
        """Random Number Generation Seed. Setting this attribute will automatically regenerate the underlying screen."""
        return self._seed
        
    @seed.setter
    def seed(self,value):
        """Random Number Generation Seed"""
        self._seed = value
        self._generate_screen()
        
    @property
    def screen(self):
        """The generated screen.
        
        .. note:: 
            This returns a reference to the screen. You should generate a new screen, or copy this 
            reference before changing any values here.
        
        """
        return self._screen
        
    def get_screen(self):
        """Return the current screen. This method is for compatibility with subclasses, and is the same as :attr:`screen`."""
        return self.screen
        
    def setup(self):
        """Set up this screen. Generate a filter (with subharmonics, if requested) and a screen.
        
        :returns: A reference to this instance (``self``)
        
        """
        self._generate_filter()
        self._generate_screen()
        return self
        
    def _generate_filter(self):
        """Use :meth:`setup` to control this method.
        
        Generate the filter required for this screen object. This method generates the filter
        (with subharmonics, if requested) that is used to generate the screen."""
        self._filter, self._shf = _generate_filter(self.shape,self.r0,self.du,self.L0,self.nsh)
        
    def _generate_screen(self):
        """Use :meth:`setup` to control this method.
        
        Generate the actual screen, using the filters produced by :meth:`_generate_filter`
        
        """
        self._screen = _generate_screen(self._filter,self.seed,self._shf,self.du)
        
        
        
    